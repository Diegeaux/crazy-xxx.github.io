// Generated by CoffeeScript 1.10.0
var ConfigForm, GameComponent, MTMain, a, br, button, calculateTargetTime, combinePairs, cxs, div, dup, el, form, game, gameInitialState, gameParamValid, gameParams, gameParamsDefaults, gameParamsInitialState, getRandomsCxs, gxs, h1, h2, h3, h4, img, input, isGtZero, label, li, local, make, memoryLogic, option, p, parseQueryParams, prepareTesting, ref, render, saveDup, select, small, span, speak, startingGameState, store, strong, timer, ul, wait,
  slice = [].slice;

ConfigForm = React.createClass({
  startGame: function(e) {
    e.preventDefault();
    if (!this.props.error) {
      return store.dispatch({
        type: 'startGame'
      });
    }
  },
  render: function() {
    return div({}, p({
      className: "lead"
    }, 'The game is not started yet. Select training time and press Start.'), form({
      className: "form-inline",
      onSubmit: this.startGame
    }, br({}), button({
      type: "submit",
      className: "btn btn-primary btn-lg",
      disabled: this.props.error
    }, 'Start training')));
  }
});

GameComponent = React.createClass({
  render: function() {
    return div({}, this.learningPhase() ? this.renderLearning() : this.renderTesting());
  },
  renderLearning: function() {
    return div({}, div({
      className: 'row'
    }, div({
      className: 'col-xs-6'
    }, this.gxImage()), div({
      className: 'col-xs-6'
    }, this.cxImage())), div({
      className: 'row',
      style: {
        marginTop: 25
      }
    }, button({
      type: "submit",
      className: "btn btn-primary btn-lg center-block",
      onClick: this.nextLearning
    }, 'Continue')));
  },
  renderTesting: function() {
    return div({}, div({
      className: 'row'
    }, div({
      className: 'col-xs-6'
    }, this.gxImage()), div({
      className: 'col-xs-6'
    }, this.renderCxs())), div({
      className: 'row',
      style: {
        marginTop: 25
      }
    }, button({
      type: "submit",
      className: "btn btn-primary btn-lg center-block",
      onClick: this.nextTest
    }, 'Continue')));
  },
  renderCxs: function() {
    var cxs;
    cxs = getRandomsCxs(this.currentPair()[1]);
    return div({}, _.map(cxs, (function(_this) {
      return function(cx) {
        return div({
          className: 'row'
        }, _this.smallCxImage(cx));
      };
    })(this)));
  },
  currentPair: function() {
    if (this.learningPhase()) {
      return this.props.pairs[this.props.currentLearning];
    } else {
      return this.props.pairs[this.props.currentTest];
    }
  },
  learningPhase: function() {
    return 'learning' === this.props.phase;
  },
  gxImage: function() {
    return this.halfSizeImage(this.currentPair()[0], 'right');
  },
  cxImage: function() {
    return this.halfSizeImage(this.currentPair()[1], 'left');
  },
  halfSizeImage: function(url, align) {
    return img({
      src: url,
      style: {
        maxHeight: '80vh',
        maxWidth: '100%',
        float: align
      }
    });
  },
  smallCxImage: function(url, align) {
    if (align == null) {
      align = 'left';
    }
    return img({
      src: url,
      style: {
        maxHeight: '25vh',
        maxWidth: '100%',
        float: align,
        marginBottom: 10
      }
    });
  },
  nextLearning: function() {
    return store.dispatch({
      type: 'nextLearning'
    });
  },
  nextTest: function() {
    return store.dispatch({
      type: 'nextTest'
    });
  }
});

gameInitialState = {
  started: false
};

game = function(state, action) {
  if (state == null) {
    state = gameInitialState;
  }
  switch (action.type) {
    case 'startGame':
      return dup(state, startingGameState());
    case 'nextLearning':
      if (state.currentLearning + 1 < state.pairs.length) {
        return dup(state, {
          currentLearning: state.currentLearning + 1
        });
      } else {
        return dup(state, prepareTesting(state.pairs));
      }
      break;
    case 'nextTest':
      if (state.currentTest + 1 < state.pairs.length) {
        return dup(state, {
          currentTest: state.currentTest + 1
        });
      } else {
        return dup(state, 1 / 0);
      }
      break;
    default:
      return state;
  }
};

startingGameState = function() {
  return {
    started: true,
    phase: 'learning',
    currentLearning: 0,
    pairs: combinePairs()
  };
};

gxs = ['http://66.media.tumblr.com/2f89f3f34d68ea4bca8611d1d49d24d3/tumblr_oc4k5qIUMD1unmtsfo1_1280.jpg', 'http://67.media.tumblr.com/b3b07eacdc76bead27531a18d84598c4/tumblr_oc4mp6XlYh1unmtsfo1_1280.jpg', 'http://66.media.tumblr.com/e12077b854342e61f521a98aa718ba56/tumblr_oc3asbyFir1unmtsfo1_1280.jpg', 'http://67.media.tumblr.com/1c417d987228a81dcb55970443237a3b/tumblr_obzgzuNH5z1unmtsfo1_1280.jpg'];

cxs = ['http://66.media.tumblr.com/e4711d4ba3cf4550be9edbf3d952aca8/tumblr_oavj8rdcu71smjd03o1_1280.jpg', 'http://67.media.tumblr.com/bf3fb8b3ff7ef7359cf692770f423db1/tumblr_oagmq610es1smjd03o1_1280.jpg', 'http://66.media.tumblr.com/a2625616a8080f4d33e9d0d9cec3c42f/tumblr_o901637P6S1qdueojo1_1280.jpg', 'http://66.media.tumblr.com/d100fd6fbee8188c2ea4fd1763e95d81/tumblr_o1nm920xfU1qfbh7io1_1280.jpg'];

combinePairs = function() {
  var sc, sg;
  sg = _.shuffle(gxs);
  sc = _.shuffle(cxs);
  return _.zip(sg, sc);
};

prepareTesting = function(pairs) {
  return {
    phase: 'testing',
    currentTest: 0,
    pairs: _.shuffle(pairs)
  };
};

getRandomsCxs = function(cx) {
  var rc, res;
  res = [cx];
  while (res.length < 3) {
    rc = _.sample(cxs);
    if (!_.contains(res, rc)) {
      res.push(rc);
    }
  }
  return res;
};

wait = 0;

timer = function() {
  game = store.getState().game;
  if (!game.started) {
    return;
  }
  if (game.countdown && (!responsiveVoice.isPlaying() || wait++ > 1)) {
    wait = 0;
    return store.dispatch({
      type: 'decreaseCountdown'
    });
  } else if (game.running) {
    if (0 === game.tasks.length || 0 === game.tasks[0].time) {
      return store.dispatch({
        type: 'nextTask'
      });
    } else {
      return store.dispatch({
        type: 'decreaseTask'
      });
    }
  }
};

setInterval(timer, 1000);

local = !top.location.hostname;

gameParamsDefaults = {
  error: false
};

parseQueryParams = function() {
  return _.object(_.map(top.location.search.substr(1).split(/&/), function(kv) {
    return kv.split(/=/);
  }));
};

gameParamsInitialState = function() {
  var ref;
  return _.assign({}, gameParamsDefaults, JSON.parse(((ref = window.localStorage) != null ? ref.gameParams : void 0) || "{}"), parseQueryParams());
};

isGtZero = function(val) {
  return _.isFinite(val) && +val > 0;
};

gameParamValid = function(prop, val, state) {
  if (prop === 'random') {
    if (!(isGtZero(state.min) && isGtZero(state.max))) {
      return false;
    }
  } else {
    if (!isGtZero(val)) {
      return false;
    }
  }
  if (prop === 'min') {
    return +val <= +state.max;
  } else if (prop === 'max') {
    return +val >= +state.min;
  } else if (prop === 'random') {
    return +state.min <= +state.max;
  } else {
    return true;
  }
};

saveDup = function() {
  var newState, objs, ref;
  objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  newState = dup.apply(null, objs);
  if ((ref = window.localStorage) != null) {
    ref.gameParams = JSON.stringify(newState);
  }
  return newState;
};

gameParams = function(state, action) {
  if (state == null) {
    state = gameParamsInitialState();
  }
  switch (action.type) {
    case 'changeType':
      return saveDup(state, {
        type: action.selected,
        error: !gameParamValid(action.selected, state[action.selected], state)
      });
    case 'changeVal':
      return saveDup(state, make(action.prop, action.val), {
        error: !gameParamValid(action.prop, action.val, state)
      });
    case 'toggleSpeech':
      return saveDup(state, {
        speechEnabled: !state.speechEnabled
      });
    case 'toggleTellTime':
      return saveDup(state, {
        tellTime: !state.tellTime
      });
    default:
      return state;
  }
};

calculateTargetTime = function() {
  var params;
  params = store.getState().gameParams;
  switch (params.type) {
    case 'random':
      return _.random(params.min * 60, params.max * 60);
    case 'minutes':
      return +params.minutes * 60;
    case 'seconds':
      return +params.seconds;
  }
};

ref = React.DOM, a = ref.a, br = ref.br, button = ref.button, div = ref.div, form = ref.form, img = ref.img, h1 = ref.h1, h2 = ref.h2, h3 = ref.h3, h4 = ref.h4, input = ref.input, label = ref.label, li = ref.li, option = ref.option, p = ref.p, select = ref.select, small = ref.small, span = ref.span, strong = ref.strong, ul = ref.ul;

el = React.createElement;

make = function(prop, val) {
  var obj;
  obj = {};
  obj[prop] = val;
  return obj;
};

dup = function() {
  var objs, state;
  state = arguments[0], objs = 2 <= arguments.length ? slice.call(arguments, 1) : [];
  return _.assign.apply(_, [{}, state].concat(slice.call(objs)));
};

memoryLogic = Redux.combineReducers({
  gameParams: gameParams,
  game: game
});

store = Redux.createStore(memoryLogic);

MTMain = React.createClass({
  render: function() {
    return div({
      className: "container"
    }, h1({}, 'Memory Test'), this.props.game.started ? el(GameComponent, this.props.game) : el(ConfigForm, this.props.gameParams));
  }
});

render = function() {
  return ReactDOM.render(el(MTMain, store.getState()), document.getElementById('content'));
};

store.subscribe(render);

render();

if (local) {
  store.subscribe(function() {
    return console.log('current state', JSON.stringify(store.getState()));
  });
}

speak = function(task) {
  if (store.getState().gameParams.speechEnabled) {
    responsiveVoice.speak(task, "UK English Female", {
      rate: 0.8
    });
  }
  return task;
};
